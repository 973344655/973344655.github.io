---
title: 风控项目交接说明一(征信API)
date: 2019-09-18 11:20:34
tags: [others]
---

## 一.整体介绍

征信项目现有140多个接口.<br>

每个接口都是一个单独的项目，有 webservice 和 springboot 两种类型，但是除了接口请求方式外，里面
具体处理逻辑基本一致。<br>

项目地址: https://code.bonc.com.cn/groups/zhengXinApi

![zhengxinapi](http://67.216.218.49:8000/file/blogs/others/zhengxinapi_01.png)


## 二.具体情况

因为所有接口基本一个流程，所以举一个例子来进行介绍(三要素验证，4档，用户状态验证).<br>

讲具体逻辑之前，先看看HBase数据存储格式.


### 1.Hbase


HBase 是一个NoSQL数据库，用于处理海量数据，可以支持10亿行百万列的大表.<br>

底层依赖于 HDFS(Hadoop Distributed File System) 作为存储空间.

#### 1.1 数据存储格式


如图这是HBase中的某张表的格式。

![Hbase1](http://67.216.218.49:8000/file/blogs/database/hbase/hbase_database_01.png)

 字段意思 : <br>

- rowkey

行键，用来确定具体的某一行。

- family

列簇，列簇将表切割成不同部分。字节数组。

- qualifier

列，列属于列簇，列的数量没有限制，可以动态添加.字节数组。

- cell

存储具体数据的单元 . 没有数据类型，字节数组的形式存储.<br>
在HBase每个cell存储单元对同一份数据有多个版本，根据唯一的时间戳来
区分每个版本之间的差异，时间戳可以由HBase(在数据写入时自动)赋值，
此时时间戳是精确到毫秒的当前系统时间，也可以由自己显示指定，按照时
间戳倒序排序，最新的数据排在最前面。

#### 1.2 从表中取数据


由{rowkey，column(family + qualifier)，version}唯一确定的单元.<br>
注意，列中包含了列簇和列簇下面具体的列.<br>

所以取数据一般流程为:<br>
得到表名 --> 得到rowkey --> 根据column取得cell --> 取出数据.

```
//table
Table table = connection.getTable(TableName.valueOf(tableName));

//rowkey
byte[] rowkeyHash = Bytes.toBytes((short)(mobnol.hashCode() & 0x7FFF));
byte[] key = Bytes.add(rowkeyHash, Bytes.toBytes(mobnol));
Get get = new Get(key);

//value
Result result = table.get(get);
if (!result.isEmpty()) {
  byte[] value = result.getValue(FAMILYNAME, QUALIFIER);
}
```

### 2.整体流程

![zhengxinapi](http://67.216.218.49:8000/file/blogs/others/zhengxinapi_02.png)

由上面可知，要获取数据，需先得到表名和rowkey,其实还需要column值，但是column固定为(f簇,q列),所以不需要再获取.


### 3.rowkey构造

rowkey的构建规则与数据入库的规则有关。<br>
征信项目现有三种类型的HBase库(主备库，信令库，交际圈库),具体在交接文档(征信接口列表—迁移后 20181212.xls)中有注明.

- 主备库

例子:https://code.bonc.com.cn/zhengXinApi/credit (三要素验证,四档)

```
byte[] rowkeyHash = Bytes.toBytes((short)("电话号码MD5".hashCode() & 0x7FFF));
byte[] key = Bytes.add(rowkeyHash, Bytes.toBytes("电话号码MD5"));
Get get = new Get(key);
```

- 信令库

例子:https://code.bonc.com.cn/zhengXinApi/query  (实时位置查询)
```
byte[] phone_id = Bytes.copy(Bytes.toBytes(Long.parseLong(TelNo)), 3, 5);
byte[] phone_id_hash = Bytes.toBytes((short) (TelNo.hashCode() & 0x7fff));
byte[] key = Bytes.add(phone_id_hash, phone_id);
Get get = new Get(key);
```

- 交际圈库

例子:https://code.bonc.com.cn/zhengXinApi/amc_istopcontact (是否联系人手机号验证，电信合作版)

```
byte[] deice_number_hash = Bytes.toBytes((short)(device_Number.hashCode() & 0x7FFF));
byte[] deice_number = Bytes.toBytes(device_Number);
byte[] oppose_number = Bytes.toBytes(oppose_Number);
byte[] key = Bytes.add(deice_number_hash, deice_number, oppose_number);
Scan s = new Scan();
s.setStartRow(Bytes.add(key, Bytes.toBytes(0)));
s.setStopRow(Bytes.add(key, Bytes.toBytes(999999999)));
```

这里是用的Scan<br>
按指定rowkey获取唯一一条记录：get方法。<br>
按指定条件获取一批记录：scan方法。

### 4.tableName获取

在这里先简单介绍下zookeeper.<br>
具体的我没仔细看，这里是一篇详细介绍的文章: https://blog.csdn.net/guchuanyun111/article/details/52091318


#### 4.1 Zookeeper简要了解

ZooKeeper主要是为分布式系统提供一致性协调(Coordination)服务。简单讲就是，如果某个节点宕机后，Zookeeper会通过选举算法重新选出一个节点，保证它不会由于单一节点的故障而造成问题.<br>

Zookeeper中存储的数据为树形结构，其上的每一个节点称为znode<br>
![znode](http://67.216.218.49:8000/file/blogs/others/zhengxinapi_znode_01.jpg)

如征信用户验证表名节点路径为
```
 <property name="zkTableNamePath" value="/fengkong/table/user_check" />
```

ZooKeeper中的Watch机制(观察者模式)：Client可以在某个ZNode上设置一个Watcher，来Watch该ZNode上的变化。如果该ZNode上有相应的变化，就会触发这个Watcher，把相应的事件通知给设置Watcher的Client。需要注意的是，ZooKeeper中的Watcher是一次性的，即触发一次就会被取消，如果想继续Watch的话，需要客户端重新设置Watcher。

#### 4.2 征信接口中的Zookeeper使用

##### 4.2.1 为什么要用zookeeper

以前征信接口项目中的表名都是放在redis还是oracle中的。表名会定期更新<br>
后来出现了机房网络割接，导致某个数据库不可用，导致接口不可用，所以将之切换到了zookeeper中，某个节点挂掉不会影响使用.

##### 4.2.2 怎么用


连接zk时，注册该节点为监控状态<br>
public ZooKeeper(String connectString, int sessionTimeout, Watcher watcher) throws IOException{}
```
public ZooKeeperConnection(String connectString, int sessionTimeOut, InitUtil initUtil) {
       this.connectString = connectString;
       this.sessionTimeOut = sessionTimeOut;
       this.initUtil = initUtil;
       try {
           //zk的连接是异步的，建立连接后会调用process方法。
           zooKeeper = new ZooKeeper("xx.xx.xx.xx:2181,xx.xx.xx.xx:2181,xx.xx.xx.xx8:2181", sessionTimeOut, this);
       } catch (IOException e) {
           e.printStackTrace();
           logger.error("zk创建失败," + e.toString());
       } catch (NullPointerException e) {
           e.printStackTrace();
           //logger.error("zk创建失败,connectString: " + prop.getConnectString() + ",sessionTimeOut: " + prop.getSessionTimeOut() + "," + e.toString());
       }

   }
```

从zk节点中获取表名,获取到数据时，重新注册为被监控状态.<br>
public byte[] getData(String path, boolean watch, Stat stat) throws KeeperException, InterruptedException { }

```
@Override
public void process(WatchedEvent event) {
   try {
       //连接事件
       if (event.getType() == Event.EventType.None) {
           logger.info("连接事件");
           //连接成功
           if (event.getState() == Event.KeeperState.SyncConnected) {
               logger.info("建立连接");
               String tableName = new String(zooKeeper.getData(initUtil.getZkTableNamePath(),true,null));
               initUtil.setTableName(tableName);

           } else if (event.getState() == Event.KeeperState.Expired || event.getState() == Event.KeeperState.Disconnected) {
               logger.info(event.getState() == Event.KeeperState.Expired ? "客户端超时" : "客户端断开连接");
               try {
                   if (zooKeeper != null) {
                       try {
                           zooKeeper.close();
                           zooKeeper = null;
                       } catch (Exception e) {
                           e.printStackTrace();
                           logger.error("zk状态:" + zooKeeper.getState() + "," + e.toString());
                       }
                   }
                   zooKeeper = new ZooKeeper(connectString, sessionTimeOut, this);
               } catch (IOException e) {
                   e.printStackTrace();
                   logger.error("zk创建失败," + e.toString());
               }
           }
       } else if (event.getType() == Event.EventType.NodeDataChanged) {
           //todo 这里是单个路径发生变化，上面是启动时/重连时 对所有路径进行监听
           logger.info("节点值变化事件");
           String tableName = new String(zooKeeper.getData(initUtil.getZkTableNamePath(),true,null));
           initUtil.setTableName(tableName);
       }
   } catch (KeeperException | InterruptedException e) {
       e.printStackTrace();
   }
}
```

### 5.数据获取

在tableName 和 rowkey 已知后，就可以直接获取数据了。但是在主备库情况下，主库备库都需要查询，又因为确定了只有两个库，所以在这里直接new了两个线程，不用使用线程池。
```
public List<String> threadQuery(Get get,String tableName,String logInfo){
	List<HbaseQueryUserThread> threadList = new ArrayList<>();
	List<String> resultList = null;
	for (String zkroot : HBasePool.getZKROOT()) {
		try {
			HbaseQueryUserThread thread = new HbaseQueryUserThread(get, HBasePool.getHConnection(zkroot), tableName, logInfo);
			thread.setName("/hbase_zx".equals(zkroot) ? "主库" : "备库");
			threadList.add(thread);
			thread.start();
		} catch (IOException e) {
			System.out.println("hbase创建出错===================================");
			e.printStackTrace();
		}
	}

	//完成计数
	int finish = 0;

	w:while (finish != threadList.size()) {
		//重置完成计数
		finish = 0;
		try {
			Thread.sleep(1);
		} catch (InterruptedException e) {
			e.printStackTrace();
		}
		for (HbaseQueryUserThread t : threadList) {
			//System.out.println(t.getName() + "线程状态：" + t.getState());
			//线程存活
			if (!t.isAlive()) {
				//结束 标识增加
				finish++;
				//赋值
				resultList = t.getList();
				//有结果
				if (t.getList().size() > 0){
					//System.out.println("跳出for");
					//中断其他线程
					for (HbaseQueryUserThread thread : threadList){
						thread.interrupt();
					}
					//跳出while循环
					break w;
				}
			}
		}
	}
	return resultList;
}
```
