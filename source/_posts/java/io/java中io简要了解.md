---
title: 几种IO模型简要了解
date: 2020-01-17 14:54:34
tags: [java]
---

https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/BIO-NIO-AIO.md

https://www.cnblogs.com/crazymakercircle/p/10225159.html



一般对服务器来说，io有文件io和网络io.

一个io 实际可以分成两个部分 (1).发起io 和 (2).实际io操作

# 一.提前准备

下面所有的阻塞/非阻塞/同步/异步只针对于io而言。

## 1.阻塞和非阻塞理解

阻塞IO和非阻塞IO的区别在于第一步，发起IO请求是否会被阻塞，如果阻塞直到完成那么就是传统的阻塞IO，如果不阻塞，那么就是非阻塞IO。

- 阻塞

一个事件的发生和响应，都得在一个线程内完成。如果这个过程很慢，则这个线程挂起，不能去干其它的事。

以socket为例，read()方法,会一直阻塞，等到输入输出流中的数据。

- 非阻塞

体现在，这个线程可以去干别的，不需要一直在这等着。

同样以socket为例，一个线程请求read()，但是发现当前流中没有数据，该线程不用一直等待可以去干其它事(发起读的请求后，就可以去干其它事)。
但是，这个线程(或者单开一个专门判读数据是否准备好的线程)，仍要定时的去读一下，看数据是否准备好了，如果没准备好，就继续去干其它事。


## 2.同步和异步理解

同步IO和异步IO的区别就在于第二个步骤是否阻塞。
如果实际的IO读写阻塞请求进程，那么就是同步IO，因此阻塞IO、非阻塞IO、IO复用、信号驱动IO都是同步IO，
如果不阻塞，而是操作系统帮你做完IO操作再将结果返回给你，那么就是异步IO。

- 同步

所谓同步，就是在发出一个功能调用时，在没有得到结果之前，该调用就不返回

- 异步

异步的概念和同步相对。当一个异步过程调用发出后，调用者不能立刻得到结果。实际处理这个调用的部件在完成后，通过状态、通知和回调来通知调用者。


# 二.几种IO模型了解

## 1.同步阻塞IO

传统的io是阻塞io(blocking-io)，通常一个事件的发生和响应，都得在一个线程内完成。
如果想要有多个操作，就得结合多线程使用。然而线程资源宝贵，线程切换开销大。


## 2.同步非阻塞NIO

non-blocking-io,同步非阻塞IO.

用户进程发起一个 IO 操作以后 边可 返回做其它事情，但是用户进程需要时不时的询问 IO 操作是否就绪，这就要求用户进程不停的去询问，从而引入不必要的 CPU 资源浪费。

注意:这里所说的NIO（同步非阻塞IO）模型，并非Java的NIO（New IO）库。

## 3.IO多路复用（Multiplexing)

多路复用，事件驱动模型之一。

每收到一个请求，放入一个事件列表，让主进程通过非阻塞I/O方式来处理请求

就是很多网络连接(多路)，共(复)用少数几个(甚至是一个)线程。连接很多的时候，不能每个连接一个线程，会耗尽系统内存的。线程也不能阻塞在任何一个连接上，等新的数据来，这样就不能及时响应其他连接发来的数据了；也不能用非阻塞方式，轮询所有的连接，这会浪费掉大量CPU时间；只能告诉系统，我对哪些连接感兴趣，有消息来的时候，通知我处理。

I/O多路复用实际上就是用select, poll, epoll监听多个io对象，当io对象有变化（有数据）的时候就通知用户进程。好处就是单个进程可以处理多个socket。

举例: 我们有很多个socket连接，但是并不是所有连接都要一直阻塞读取写入，因为实际上很多时间都是无意义等待。这时候就可以有一个或多个专门的线程，来处理这些socket,当有新的消息时，通知对应得线程进行处理。

## 4.异步非阻塞AIO

用户线程发起一个调用之后无须等待, 可以处理别的事情. 由操作系统等待接收内容, 接收后把数据拷贝到用户进程中, 最后通知用户程序(回调)已经可以使用数据了。
