---
title: 线程池简要了解
date: 2019-07-27 16:43:55
tags: [java]
---

# 一.为什么要用线程池

为了并发的执行任务，减少任务执行时间，提升性能 ---多线程.<br>
减少创建和销毁线程的次数(复用)，同时方便管理 --- 线程池<br>

# 二.线程池

## 1.ThreadPoolExecutor

ThreadPoolExecutor 允许我们灵活的定义自己的线程池.<br>

```
ThreadPoolExecutor(int corePoolSize,
                        int maximumPoolSize,
                        long keepAliveTime,
                        TimeUnit unit,
                        BlockingQueue<Runnable> workQueue,
                        ThreadFactory threadFactory,
                        RejectedExecutionHandler handler)
```
- corePoolSize

核心线程数，默认情况下核心线程会一直存活，即使处于闲置状态也不会受存keepAliveTime限制。除非将allowCoreThreadTimeOut设置为true。

- maximumPoolSize

线程池所能容纳的最大线程数。超过这个数的线程将被阻塞。当任务队列为没有设置大小的LinkedBlockingDeque时，这个值无效。

- keepAliveTime

非核心线程的闲置超时时间，超过这个时间就会被回收

- unit

指定keepAliveTime的单位，如TimeUnit.SECONDS。当将allowCoreThreadTimeOut设置为true时对corePoolSize生效。

- workQueue

线程池中的任务队列.<br>
常用的有三种队列：SynchronousQueue,LinkedBlockingDeque,ArrayBlockingQueue。

- threadFactory

线程工厂，提供创建新线程的功能。ThreadFactory是一个接口，只有一个方法

```
public interface ThreadFactory {
  Thread newThread(Runnable r);
}
```
- RejectedExecutionHandler

RejectedExecutionHandler也是一个接口，只有一个方法

```
public interface RejectedExecutionHandler {
  void rejectedExecution(Runnable var1, ThreadPoolExecutor var2);
}
```
默认: AbortPolicy、CallerRunsPolicy、DiscardOldestPolicy、DiscardPolicy

## 2.四种线程池 和 ThreadPoolExecutor关系

四种线程池只是和ThreadPoolExecutor一样的ExecutorSerivice的其它四种实现方式  ，我们可以根据情况灵活选用或者自定义自己的线程池.<br>

- newSingleThreadExecutor

创建一个单线程的线程池,这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行

- newFixedThreadPool

创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。

- newCachedThreadPool

创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，
那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。

- newScheduledThreadPool

创建一个大小无限的线程池。此线程池支持定时以及周期性执行任务的需求。



## 3.ThreadPoolExecutor 和 ThreadPoolTaskExecutor关系

ThreadPoolTaskExecutor 是 ThreadPoolExecutor 在spring中的实现方式。

# 三.线程池加异步，为什么

异步任务特点就是不阻塞。<br>
和线程池一起使用时，可以异步的获取线程的返回结果<br>

重点是这个可以很方便的获取到返回结果。<br>

其它原因，还未理解到<br>


# 四.Runnable 和  Callable

```
public interface Runnable {
    public abstract void run();
}

```
```
public interface Callable<V> {
    V call() throws Exception;
}
```

可以看到:<br>

1.runable可以得到返回结果，所以可以配合Future实现异步<br>
2.可以抛出异常<br>

# 五.Spring @Async

spring中 @Async 会优先使用自定义线程池，如果没有自定义的Executor，所以使用缺省的TaskExecutor
