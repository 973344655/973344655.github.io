---
title: 设计模式--工厂模式三(抽象工厂模式)
date: 2019-11-13 13:48:54
tags: [base]
---

## 1.抽象工厂模式

工厂方法模式在大多数情况下已经可以了，但是它每个工厂只能创建一种商品，在某些情况下显得不够用。

抽象工厂模式，提供一个创建一系列相关对象的接口，而无需指定它们具体的类。我的理解就是，将product再多了一层抽象。每个特定工厂，生产特定类型的product(某个接口或抽象类)。

实际上多了个产品族的概念。

同时，工厂也变成了超级工厂，这个超级工厂负责创建其它工厂。

每个产品族可以包括多种产品。
![abstract_factory](http://67.216.218.49:8000/file/blogs/base/abstract_factory_01.png)


## 2.角色

- factory

抽象工厂类(超级工厂)。

- concreteFactory

具体的某种工厂

- product

抽象产品。

- productFamily

抽象的产品族

- concerteProduct

具体的产品


## 3.例子

```

//超级工厂
interface Factory{

     ProductFamily1 getProductFamily1(int type);
     ProductFamily2 getProductFamily2(int type);
}

// 负责产品族1的工厂
class Factory1 implements Factory{

    @Override
    public ProductFamily1 getProductFamily1(int type) {
        if(type == 1){
            return new Product1();
        }else {
            return new Product2();
        }
    }

    @Override
    public ProductFamily2 getProductFamily2(int type) {
        return null;
    }


}

//负责产品族2的工厂
class Factory2 implements Factory{

    @Override
    public ProductFamily1 getProductFamily1(int type) {
        return null;
    }

    @Override
    public ProductFamily2 getProductFamily2(int type) {
        switch (type){
            case 1 : return new Product3();
            case 2 : return new Product4();
            default: return null;
        }
    }
}

//负责选择具体工厂，(不一定需要?)
class SuperFactory{
    public Factory getFactory(int type){
        switch (type){
            case 1 : return new Factory1();
            case 2 : return new Factory2();
            default: return null;
        }
    }
}

//产品族1
interface ProductFamily1{
    void print();
}

class Product1 implements ProductFamily1{
    @Override
    public void print() {
        System.out.println("Product1");
    }
}

class Product2 implements ProductFamily1{
    @Override
    public void print() {
        System.out.println("Product2");
    }
}

//产品族2
interface ProductFamily2{
    void draw();
}

class Product3 implements ProductFamily2{
    @Override
    public void draw() {
        System.out.println("Product3");
    }
}

class Product4 implements ProductFamily2{
    @Override
    public void draw() {
        System.out.println("Product4");
    }
}


//开始生产产品了
public class MyAbstractFactoryDemo {

    public static void main (String[] args){
        //要生产产品1
        //需要先得到工厂1
        Factory factory1 = new SuperFactory().getFactory(1);
        //生产
        ProductFamily1 product1 = factory1.getProductFamily1(1);
        product1.print();

        //生产产品3
        Factory factory2 = new SuperFactory().getFactory(2);
        ProductFamily2 product3 = factory2.getProductFamily2(1);
        product3.draw();
    }



}


```


## 4.理解

写完一遍，清晰多了。

抽象工厂模式，和工厂方法模式相比，感觉就是一个加大版的超级工厂。可以生产出不同的工厂，不同的工厂再去生产不同的具体产品族。

而工厂方法模式，就是每个工厂生产其自己不同产品。

简而言之就是 工厂方法模式的工厂生产产品，抽象工厂方法模式的工厂生产产品族。

在生产产品族的时候，也有判断，所以也没遵从开闭原则。
