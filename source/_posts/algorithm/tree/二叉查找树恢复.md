---
title: 二叉查找树恢复 leetcode 99
date: 2019-08-14 10:03:30
tags: [algorithm]
---

https://leetcode.com/problems/recover-binary-search-tree/

# 一.原理

二叉查找树的性质决定了，它的中序遍历(左根右) 为递增序列。<br>

所以对二叉树进行中序遍历，判断是否大小有序，找到第一出现前面的值大于后面的值的位置index,和index1大于的最后一个值的index2,交换index1和index2的值.

# 二.实现

## 1.基本实现<br>
Runtime: 4 ms, faster than 22.08%<br>
Memory Usage: 39.8 MB, less than 80.77%<br>

```
class Solution {
    public void recoverTree(TreeNode root) {
        List<TreeNode> list = inOrder(root);

        //标记错误的两个位置
        int index1 = 0;
        int index2 = 0;
        //第一个错误的值
        Integer value1 = null;
        //是否发现第一个错误位置
        boolean lockIndex1 = false;

        for (int i = 0; i<list.size(); i++){
            //跳过null
            if(list.get(i) != null){
                //初始化赋值
                if(value1 == null ){
                    value1 = list.get(i).val;
                    index1 = i;
                }

                //逐渐向后比较，找到最终index2位置
                if(value1 > list.get(i).val){
                    index2 = i;
                    lockIndex1 = true;
                }

                //锁定index1位置
                if(!lockIndex1){
                    value1 = list.get(i).val;
                    index1 = i;
                }
            }

            //交换值
            if(i == list.size() -1){
                list.get(index1).val = list.get(index2).val;
                list.get(index2).val = value1;
            }
        }

        //list.stream().map(e -> e.val).forEach(System.out::println);
    }

        //中序遍历
    List<TreeNode> list = new LinkedList<>();
    public List<TreeNode> inOrder(TreeNode root){
        if(root != null){
            //遍历它的左下级节点
            inOrder(root.left);
            list.add(root);
            //左节点完后，遍历右节点
            inOrder(root.right);
        }
        return list;
    }

}
```

包括树的构建赋值的全代码
```
import java.util.ArrayList;
import java.util.Arrays;
import java.util.LinkedList;
import java.util.List;

public class TreeTest {

    class TreeNode {
        Integer val;
        TreeNode left;
        TreeNode right;

        TreeNode(Integer x) {
            this.val = x;
            this.right = null;
            this.left = null;
        }
    }

    class Tree{
        TreeNode root = null;
        List<TreeNode> nodeList = new ArrayList<>();

        Tree(List<Integer> list){
            for(Integer data: list){
               nodeList.add(new TreeNode(data));
            }

            //按层次遍历顺序初始化二叉树
            for(int row=0; nodeList.size() >= Math.pow(2, row) -1 && nodeList.size() >= Math.pow(2, row) -1 ; row++){
                for(int col=0; col<Math.pow(2,row); col++){
                    //当前节点
                    int index = (int)Math.pow(2, row) + col - 1;
                    //当前节点的子节点
                    int index2 = (int)Math.pow(2, row + 1) + 2*col - 1;

                    if(nodeList.size()> index){
                        //有左右节点
                        if (nodeList.size()> index2+1 ){
                            nodeList.get(index).left = nodeList.get(index2);
                            nodeList.get(index).right = nodeList.get(index2+1);
                        //只有左节点
                        }else if(nodeList.size()> index2){
                            nodeList.get(index).left = nodeList.get(index2);
                            nodeList.get(index).right = null;
                        //没有子节点
                        }else {
                            nodeList.get(index).left = null;
                            nodeList.get(index).right = null;
                        }
                    }
                }
            }
            //返回根节点
            root = nodeList.get(0);
        }
    }

    //中序遍历
    List<TreeNode> list = new LinkedList<>();
    public List<TreeNode> inOrder(TreeNode root){
        if(root != null){
            //遍历它的左下级节点
            inOrder(root.left);
            list.add(root);
            //左节点完后，遍历右节点
            inOrder(root.right);
        }
        return list;
    }

    // 二叉查找树恢复
    public void recoverTree(TreeNode root) {
        List<TreeNode> list = inOrder(root);

        //标记错误的两个位置
        int index1 = 0;
        int index2 = 0;
        //第一个错误的值
        Integer value1 = null;
        //是否发现第一个错误位置
        boolean lockIndex1 = false;

        for (int i = 0; i<list.size(); i++){
            //跳过null
            if(list.get(i).val != null){
                //初始化赋值
                if(value1 == null ){
                    value1 = list.get(i).val;
                    index1 = i;
                }

                //逐渐向后比较，找到最终index2位置
                if(value1 > list.get(i).val){
                    index2 = i;
                    lockIndex1 = true;
                }

                //锁定index1位置
                if(!lockIndex1){
                    value1 = list.get(i).val;
                    index1 = i;
                }
            }

            //交换值
            if(i == list.size() -1){
                list.get(index1).val = list.get(index2).val;
                list.get(index2).val = value1;
            }
        }

       //list.stream().map(e -> e.val).forEach(System.out::println);
    }


    public static void main(String[] args){
        List<Integer> list = Arrays.asList(1,3,null,null,2);
        Tree tree = new TreeTest().new Tree(list);
        new TreeTest().recoverTree(tree.root);
    }
}
```

## 2.优化1
