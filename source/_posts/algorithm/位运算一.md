---
title: 位运算专题一
date: 2019-11-26 11:39:30
tags: [algorithm]
---
位运算入门: https://www.jiuzhang.com/tutorial/bit-manipulation/73


# 一.位运算基础

## 1.原码、反码、补码

首先要知道一点，计算机中整数都是用补码存储的。

##### 计算机为什么要使用补码

因为减一个数等于加上它的补数
https://blog.csdn.net/leonliu06/article/details/78685197
```
//在十进制中  补数为 x + 补数 = 0
5 - 3 = 5 + (-3)
//在二进制中
0101 - 3 = 0101 - (0011)
         = 0101 + (1100 + 1) //负数的补码等于反码 + 1
         = 0010 = 2
```
而在计算机中，算数逻辑单元ALU,计算加法最简单，使用补码，可以忽略负数的符号影响

##### 三码与真值转换


- 整数

整数的原码，反码，补码都一样

- 负数

真值转码：<br>
反码为除符号位外，每位取反<br>
补码为，反码加一

码转真值:<br>
补码取反，再加1

## 2.位运算

- & 与

```
1 & 1 = 1
1 & 0 = 0
0 & 0 = 0
```
- | 或

```
1 | 1 = 1
1 | 0 = 1
0 | 0 = 0
```

- ~ 非

非操作为取反操作
```
A =   (1)10 = (00000000000000000000000000000001)2
~A = ~ (1)10 = (11111111111111111111111111111110)2 = (-2)10
```
~1 值为 -2

解释下:
```
10000000000000000000000000000001  // -1源码表示
11111111111111111111111111111110  // -1反码
11111111111111111111111111111111  // -1补码

~A = ~(1)10 = ~(00000000000000000000000000000001)2
   = ~(11111111111111111111111111111110)  // 1的非运算结果
//转化为真值  取反 + 1
10000000000000000000000000000001  //取反
10000000000000000000000000000010  // +1 值为-2

```

- ^ 异或

```
1 ^ 1 = 0
1 ^ 0 = 1
0 ^ 0 = 0
```

- \>>     \>>> 右移

带符号右移 >>

将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补符号位的数（比如负数符号位是1则补充1，正数符号位是0则补充0），所以对于算术右移，原来是负数的，结果还是负数，原来是正数的结果还是正数。
```
A = (-127)10 >> 2 = (11111111111111111111111110000001)2 >> 2 = (11111111111111111111111111100000)2 = (-32)10
```

逻辑右移 >>>

将A的二进制表示的每一位向右移B位，右边超出的位截掉，左边不足的位补0。所以对于逻辑右移，结果将会是一个正数

举个例子对于十进制数-127, 已知(-127)10 = (11111111111111111111111110000001)2 , 因为是负数，所以最高位上是1

```
A = (-127)10 >> 2 = (11111111111111111111111110000001)2 >> 2 = (00111111111111111111111111100000)2 = (1073741792)10
```

- <<  左移

将二进制表示的整体向左移 n位，左边超出 32 位的截掉（int类型为32位），右边不足的位补 0
比如对于10进制数12，他的二进制表示下，是1100，那么将其左移 2 位，得到的结果是 110000。

可以发现，在不溢出的情况下，左移n位，相当于 乘了 2的n次方
```
A << B = A * 2^B
```

# 为什么要用位运算

位运算速度快

# 怎么用
