---
title: 平衡二叉树了解一下
date: 2019-08-20 17:02:30
tags: [algorithm]
---


# 一.什么是平衡二叉树

平衡二叉树也是一种二叉查找树，有以下特点:

- 1.可以是空树。
- 2.假如不是空树，任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1 (即高度要平衡)

# 二.为什么要有平衡二叉树，即优缺点

- 优

在树这种数据结构中，树的高度影响着查找速度，层数越少，需要查询的次数越少，效率越高。
而平衡二叉树，能减少树的高度，防止出现极端O(N)的情况，使效率稳定为O(logN).


- 缺

当数据量越来越大时，为了保证高度平衡，动态插入和删除的代价也随之增加。<br>

在大数据量查找环境下(如数据库记录查找)，在二叉树结构下(2*N -1),N的层会太大，造成硬盘IO读写次数过多。(使用多路查找树).



# 三.怎么实现

AVL树，平衡二叉树的最早实现之一。以下为AVL树的实现.

### 1.原理

因为平衡二叉树比二叉查找树多了一些性质来保证高度平衡.所以在每一次插入数值之后，树的平衡性都可能被破坏，这时可以通过一个简单的操作来矫正平衡–--旋转。<br>

旋转的目的就是减少高度，通过降低整棵树的高度来平衡。哪边的树高，就把那边的树向上旋转。

四种旋转:<br>

旋转是以失衡的节点为基准的<br>
LL的解释, 第一个L代表根节点左边，第二个L代表插入的为左节点<br>

- LL（左子树的左节点上插入节点而破坏平衡）：右旋转

第一个 L: <strong>左子树</strong> <br>
第二个 L: 失衡节点的左孩子的 <strong>左节点</strong>.

![LL](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_LL.webp)

- RR（右子树的右节点上插入节点而破坏平衡）：左旋转


第一个 R: <strong>右子树</strong> <br>
第二个 R: 失衡节点的右孩子的 <strong>右节点</strong>.
![RR](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_RR.webp)

- LR（左子树的右节点上插入节点而破坏平衡）：先左旋后右旋

第一个 L: <strong>左子树</strong> <br>
第二个 R: 失衡节点的左孩子的 <strong>右节点</strong>.
![LR](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_LR.webp)

- RL（右子树的左节点上插入节点而破坏平衡）：先右旋后左旋

第一个 R: <strong>右子树</strong> <br>
第二个 L: 失衡节点的右孩子的 <strong>左节点</strong>.
![RL](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_RL.webp)



### 2.实现代码
```
public class MyTest {

    private static class Node<E>{
        E elment;
        Node<E> left;
        Node<E> right;
        int height;

        Node(E elment){
            this(elment, null, null);
        }
        Node(E elment, Node left, Node right){
            this.elment = elment;
            this.left = left;
            this.right = right;
        }

    }

    private static class AVLTree<E extends Comparable<? super E>>{
        Node root;

        public AVLTree(){
            this.root = null;
        }
        public void insert(E elment){
            this.root = insert(this.root, elment);
        }
        //递归找到要插入的位置插入，同时在return中平衡高度
        public Node insert(Node<E> root, E elemet){
            if( root == null ){
                return new Node(elemet);
            }

            if(elemet.compareTo(root.elment) < 0 ){
                //左边插入
                root.left = insert(root.left, elemet);
                //在return后平衡高度,因为是在左边插入，所以如果高度不平衡，只会是左边高于右边
                if(height(root.left) - height(root.right) == 2){
                    //判断是插在子节点的左边还是右边
                    if(elemet.compareTo(root.left.elment) < 0){
                        //LL
                        root = nodeLL(root);
                    }else {
                        //LR
                        root = nodeLR(root);
                    }
                }

            }else if(elemet.compareTo(root.elment) > 0){
                //右边插入
                root.right = insert(root.right, elemet);
                //在return后平衡高度,因为是在右边插入，所以如果高度不平衡，只会是右边高于左边
                if(height(root.right) - height(root.left) == 2){
                    //判断是插在子节点的左边还是右边
                    if(elemet.compareTo(root.right.elment) < 0){
                        //RL
                        root = nodeRL(root);
                    }else {
                        //RR
                        root = nodeRR(root);
                    }
                }
            }

            //更新节点高度
            root.height = Math.max(height(root.left),height(root.right)) + 1;
            return root;
        }

        //右旋
        private Node nodeLL(Node node){
            //旋转
            Node newNode = node.left;
            newNode.right = new Node(node.elment);
            //调整高度值
            newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
            return newNode;
        }
        //左旋
        private Node nodeRR(Node node){
            Node newNode = node.right;
            newNode.left = new Node(node.elment);
            newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
            return newNode;
        }
        //左旋再右旋
        private Node nodeLR(Node node){
            Node newNode = node.left.right;
            newNode.left = new Node(node.left.elment);
            newNode.right = new Node(node.elment);
            newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
            return newNode;
        }
        //右旋再左旋
        private Node nodeRL(Node node){
            Node newNode = node.right.left;
            newNode.left = new Node(node.elment);
            newNode.right = new Node(node.right.elment);
            newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
            return newNode;
        }

        private int height(Node node){
            return node == null ? -1:node.height;
        }

    }


    public static void main(String[] args){

        AVLTree tree = new AVLTree();
        tree.insert(5);
        tree.insert(4);
        tree.insert(6);
        tree.insert(3);
        tree.insert(2);

        System.out.println(tree.root.elment);
        System.out.println(tree.root.left.left.elment);
        System.out.println(tree.root.left.right.elment);
    }
}

```

### 3.顺着代码来理一下逻辑

1.定义节点类Node,其中height记录当前节点的高度，用来判断是否失衡

2.定义AVL树，其实就一个root节点

3.提供四种旋转方法，以失衡的节点为参

4.通过insert() 不断插入来构建一棵AVL树

主要注意insert(Node<E> root, E elemet)方法.
通过递归，找到新节点的插入点，并插入，然后在一层层的返回结果中判断是否失衡，并调整。

如图:<br>
![insert](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_insert1.PNG)

已有一棵平衡二叉树，再插入一个节点，节点值为2.<br>
根据代码，相应流程如下:
- 1.递归找到插入点
- 2.在return中判断是否打破平衡，并进行调整.

![insert2](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_insert2.PNG)
```
1.insert(Node(5), 2);
2.    insert(Node(4), 2);
3.        insert(Node(3), 2);
4.            insert(null, 2);
5.            return Node(2);
6.        Node(3).left = Node(2); return Node(3);
7.    Node(4).left = Node(3); height == 2;
      旋转调整 Node(4) = LL(Node(4)); return Node(4);
8.Node(5).left = Node(4); return Node(5);

Node(5).right 即根节点的右子树，在本例中无变化
```

## 四.节点删除操作

节点删除分为 删除节点 和 调整平衡两步.

### 1.删除节点

删除节点后 要保证剩下还是一棵二叉查找树(有序)。为了保证此条件，我们对删除的三种情况进行分析。<br>

- 删除的节点为叶子节点

此时可以直接删除。

- 删除对的节点有一个子节点

此时，无论是有左子节点还是右子节点，可以直接将要删除的节点直接用子节点进行替换。

- 删除的节点有两个子节点

此时判断下要删除的节点的左右子树高度， 若 height(left) >= height(right), 则取 左子树的最大值节点， 如 height(left) < height(right), 则取 右子树的最小值节点. 同时删除该取值的节点。<br>

不管是最大值还是最小值节点，肯定都是叶子节点。<br>



### 2.调整平衡

#### (1)情况分析

不同于插入, 如图:

![LL2](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_LL_02.png)

如上图中图一，新增的时候，只会有节点1 和 节点3 中的一个，不可能同时出现两个的情况，因为，当第一个出现时，节点4就已经失衡，进行调整了。<br>

如上图中图二，当删除时，删除节点5， 会出现节点4失衡， 但是会出现 节点1和节点3 同时存在的情况。此时，将失衡类型 归入 LL 里面.<br>

同理，会出现两个子树同时存在的 RR 情况.<br>

在删除时，可能会出现失衡节点的子节点同时有左右子节点情况。所以，在调整平衡时，于插入有点不一样。如下图， 此时将 1，3 作为 LL, 将 2 作为 LR.<br>

![LL4](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_LL_04.png)

- LL：右旋转

第一个 L: <strong>左子树</strong> <br>
第二个 L: 失衡节点的左孩子的 <strong>左节点</strong>, <font color=#A52A2A>或 <strong>同时有左右节点</strong> </font>.


- RR：左旋转

第一个 R: <strong>右子树</strong> <br>
第二个 R: 失衡节点的右孩子的 <strong>右节点</strong>,<font color=#A52A2A>或 <strong>同时有左右节点</strong> </font>.


- LR：先左旋后右旋

第一个 L: <strong>左子树</strong> <br>
第二个 R: 失衡节点的左孩子的 <strong>右节点</strong>.


- RL）：先右旋后左旋

第一个 R: <strong>右子树</strong> <br>
第二个 L: 失衡节点的右孩子的 <strong>左节点</strong>.




#### (2)具体变化

- LL

LL 为右旋， 所以按照右旋的步骤：

```
//右旋
private Node nodeLL(Node node){
    //1.将失衡节点的左节点提升
    Node newNode = node.left;
    //2.将失衡节点下降
    newNode.right = new Node(node.elment);
    //调整高度值
    newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
    return newNode;
}
```


此时，失衡节点的左子节点的右子节点还未处理,将该右子节点作为失衡节点左节点改变代码为:
```
//右旋
private Node nodeLL(Node node){
    //1.将失衡节点的左节点提升
    Node newNode = node.left;
    //2.将失衡节点下降
    newNode.right = new Node(node.elment);
    //3.失衡节点的左子节点的右子节点处理
    newNode.right.left = node.left.right;
    //调整高度值
    newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
    return newNode;
}
```

如图:
![LL3](http://67.216.218.49:8000/file/blogs/algorithm/avl_tree_LL_03.png)

当失衡节点的左子节点的右子节点 不存在， 即为null,时，这样处理无影响。此时就和插入的平衡处理一个效果。

- RR

参照 LL, RR进行左旋操作

```
//左旋
private Node nodeRR(Node node){
    //1.将失衡节点的右子节点提升
    Node newNode = node.right;
    //2.将失衡节点下沉
    newNode.left = new Node(node.elment);
    //3.失衡节点的右节点的左孩子处理
    newNode.left.right = node.right.left;
    //调整高度
    newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
    return newNode;
}
```


此时，插入和删除的代码可以合并.

#### (3)性能

- 查找

O(logn).

- 插入

O(logn) + 旋转。

插入时，最多需要旋转1次(单旋转或双旋转).

- 删除

O(logn) + 旋转.

删除之后必须检查从删除结点开始到根结点路径上的所有结点的平衡因子。每一次删除操作最多需要O(logN)次旋转。因此，删除操作的时间复杂度为O(logN)+O(logN)=O(2logN)


### 3.完整代码

```
public class MyTest {


    private static class Node<E>{
        E elment;
        Node<E> left;
        Node<E> right;
        int height;

        Node(E elment){
            this(elment, null, null);
        }
        Node(E elment, Node left, Node right){
            this.elment = elment;
            this.left = left;
            this.right = right;
        }

    }

    private static class AVLTree<E extends Comparable<? super E>>{
        Node root;

        public AVLTree(){
            this.root = null;
        }
        public void insert(E elment){
            this.root = insert(this.root, elment);
        }

        public void delete(E elment){
            if (elment != null){
                this.root = delete(this.root, elment);
            }
        }

        //递归找到要插入的位置插入，同时在return中平衡高度
        public Node insert(Node<E> root, E elemet){
            if( root == null ){
                return new Node(elemet);
            }

            if(elemet.compareTo(root.elment) < 0 ){
                //左边插入
                root.left = insert(root.left, elemet);
                //在return后平衡高度,因为是在左边插入，所以如果高度不平衡，只会是左边高于右边
                if(height(root.left) - height(root.right) == 2){
                    //判断是插在子节点的左边还是右边
                    if(elemet.compareTo(root.left.elment) < 0){
                        //LL
                        root = nodeLL(root);
                    }else {
                        //LR
                        root = nodeLR(root);
                    }
                }

            }else if(elemet.compareTo(root.elment) > 0){
                //右边插入
                root.right = insert(root.right, elemet);
                //在return后平衡高度,因为是在右边插入，所以如果高度不平衡，只会是右边高于左边
                if(height(root.right) - height(root.left) == 2){
                    //判断是插在子节点的左边还是右边
                    if(elemet.compareTo(root.right.elment) < 0){
                        //RL
                        root = nodeRL(root);
                    }else {
                        //RR
                        root = nodeRR(root);
                    }
                }
            }

            //更新节点高度
            root.height = Math.max(height(root.left),height(root.right)) + 1;
            return root;
        }

        //右旋
        private Node nodeLL(Node node){
            //1.将失衡节点的左节点提升
            Node newNode = node.left;
            //2.将失衡节点下降
            newNode.right = new Node(node.elment);
            //3.失衡节点的左子节点的右子节点处理
            newNode.right.left = node.left.right;
            //调整高度值
            newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
            return newNode;
        }
        //左旋
        private Node nodeRR(Node node){
            //1.将失衡节点的右子节点提升
            Node newNode = node.right;
            //2.将失衡节点下沉
            newNode.left = new Node(node.elment);
            //3.失衡节点的右节点的左孩子处理
            newNode.left.right = node.right.left;
            //调整高度
            newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
            return newNode;
        }
        //左旋再右旋
        private Node nodeLR(Node node){
            Node newNode = node.left.right;
            newNode.left = new Node(node.left.elment);
            newNode.right = new Node(node.elment);
            newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
            return newNode;
        }
        //右旋再左旋
        private Node nodeRL(Node node){
            Node newNode = node.right.left;
            newNode.left = new Node(node.elment);
            newNode.right = new Node(node.right.elment);
            newNode.height = Math.max(height(newNode.left), height(newNode.right)) + 1;
            return newNode;
        }

        private int height(Node node){
            return node == null ? -1:node.height;
        }


        public Node delete(Node<E> root, E element){
            if (root == null){
                return null;
            }

            if(element.compareTo(root.elment) < 0){
                //左递归
                root.left = delete(root.left, element);
                //重新调整平衡，删除左边，调整右边
                if(height(root.left) - height(root.right) == 2 || height(root.left) - height(root.right) == -2){
                    //判断是哪种调整方式
                    // 只有失衡节点的右子树的左节点
                    if(root.right.right == null){
                        //RL
                        root = nodeRL(root);
                    }else {
                        //RR
                        root = nodeRR(root);
                    }
                }
            }else if(element.compareTo(root.elment) > 0){
                //右递归
                root.right = delete(root.right, element);
                //重新调整平衡，删除右边，调整左边
                if(height(root.right) - height(root.left) == 2 || height(root.right) - height(root.left) == -2){
                    //判断调整类型
                    //只有失衡节点的左子树的右节点
                    if(root.left.left == null){
                        //LR
                        root = nodeLR(root);
                    }else {
                        //LL
                        root = nodeLL(root);
                    }
                }
            }else {
                //删除
                if(root.left != null && root.right != null){
                    //有两个子节点
                    //找到替换得节点，右子树最小值
                    root.elment = findElement(root);
                    //删除替换节点，替换节点一定是叶子节点
                    delete(root.right, root.elment);

                }else if(root.left == null && root.right == null){
                    //无子节点，自己是叶子节点
                    root = null;
                }else {
                    //有一个子节点
                    root = root.left != null ? root.left : root.right;
                }
            }
            return root;
        }

        //判断替换点为左子树最大还是右子树最小
        private E findElement(Node<E> root){
            if(height(root.left) >= height(root.right)){
                return findLeftMax(root.left);
            }else {
                return findRightMin(root.right);
            }
        }
        private E findRightMin(Node<E> root){
            while (root.left != null){
                root = root.left;
            }
           return root.elment;
        }
        private E findLeftMax(Node<E> root){
            while (root.right != null){
                root = root.right;
            }
            return root.elment;
        }
    }


    public static void main(String[] args){

        AVLTree tree = new AVLTree();
        tree.insert(4);
        tree.insert(2);
        tree.insert(5);
        tree.insert(1);
        tree.insert(3);


        System.out.println(tree.root.elment);
        tree.delete(5);
        System.out.println(tree.root.elment);


    }
}

```
