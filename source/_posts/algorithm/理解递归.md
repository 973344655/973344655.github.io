---
title: 理解递归
date: 2019-08-20 11:08:34
tags: [algorithm]
---

对递归的理解总是不是很清晰。但是又非常重要，学习记录一下.

## 1.经典例子Fibonacc

斐波那契数列是指1，1，2，3，5，8，13，21…的一个数列，它的规律就是某一个数就是前面两个数的和.

### (1)实现
```
public class MyTest {

    public int fibonacc(int n){
        if(n == 0 || n == 1){
            return 1;
        }else {
            //递归
            return fibonacc(n-2) + fibonacc(n-1);
        }
    }

    public static void main(String[] args){
        System.out.println(new MyTest().fibonacc(4));
    }
}
```

### (2)流程

```
1.fi(4)
2.  fi(3)                       +               fi(2)
3.    fi(2)               +   fi(1)      +        fi(1) + fi(0)
4.      fi(1) + fi(0)     +   return     +        return + return
5.      return + return          +              return
6.    return
7.  return
8.return
```
如上,当求fi(4)的时候，进入递归，求出fi(3),fi(2),fi(1);

## 2.为什么要用递归？

在适合的场景下，递归代码非常简洁清晰，描述问题易于理解。<br>

但是，如果调用层数比较深，需要增加额外的堆栈处理（还有可能出现堆栈溢出的情况），比如参数传递需要压栈等操作，会对执行效率有一定影响。

## 3.对于递归的理解

### (1)通用结构

```
func(){
  if(结束条件){
    return;
  }else{
    //递归
    func();
  }
}
```
递归存在一个终止条件，每次递归会越来越接近这个终止条件。

### (2)理解

递归类似于循环，有一个繁琐的操作，但是每一步之间有相似性，可以将之拆分为不同层次，循环处理，每个层次都会有自己的返回结果或者操作照成的影响。

### (3)树的递归遍历
```
//中序 左中右
public void inOrder(TreeNode root){
    if(root != null){
        //遍历它的左下级节点
        inOrder(root.left);
        System.out.println(root.val);
        //左节点完后，遍历右节点
        inOrder(root.right);
    }
}

//前序 中左右
public void beforeOrder(TreeNode root){
    if(root != null){
        System.out.println(root.val);
        //遍历它的左下级节点
        beforeOrderOrder(root.left);
        //左节点完后，遍历右节点
        beforeOrderOrder(root.right);
    }
}

//后续 左右中
public void afterOrder(TreeNode root){
    if(root != null){
        //遍历它的左下级节点
        afterOrder(root.left);
        //左节点完后，遍历右节点
        afterOrder(root.right);
        System.out.println(root.val);
    }
}
```

以中序遍历为例: 从根节点开始。<br>
![tree](http://67.216.218.49:8000/file/blogs/algorithm/tree02.png)<br>

如图，要进行中序遍历：

1.F.left -> B.left -> A.left(无)  return A<br>
2.return B<br>
3.B.right -> D.left -> C.left(无) return C<br>
4.return D<br>
5.D.right -> E.left(无) return E<br>
.....

可以看见，从根节点开始，先 从左节点开始，层层遍历(递归)，找到最左子节点.<br>
然后会跳出当层循环(最下层),得到B<br>
然后B查找其右节点，存在，则从右节点开始，查找左节点。<br>

总结，一层遍历分为查找左节点(如果存在) -> 找到自己 -> 查找右节点(如果存在) 三步，所以这三步可以成为一个基本递归单位.

root == null 为其结束条件。
